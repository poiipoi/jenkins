@Library('dco') import acronis.dco.*
import groovy.json.JsonOutput
import groovy.json.JsonSlurper

import acronis.dco.Utilities

utils = new acronis.dco.Utilities(this)


INVENTORY = 'production-deployment-environments/inventories/production/globalrouter-baas'
dc = utils.findDCByInventory(INVENTORY)
deployer_id = utils.getDeployUserID(dc)
deployer_username = utils.getDeployUserUsername(dc)
expiring_certs = 'expiring_certs.json'
renew_certificate = true
BUILD_VERSION= '25.02'
PLAYBOOK_NAME = "playbook_ssl_certificate.yml"
EXTRA_VARS = " -e expiry_days=360 -e pdc=\${params.PDC} -e vdc=\${params.VDC} "


def printToConsoleAndSendMessage(String message) {
    echo "\${message}"
    // Sends message to Teams channel "Ansible notifcations" team name "Datacenter Operations"
    ChatHelper chat = new ChatHelper(this, [channel: "19:4a74c47277c34867873a83e723cdfe42@thread.tacv2"])
    chat.sendMessage(message)
}

node('master') {
    cleanWs()

    utils.defineAbsentParameters()

    stage('Checkout') {
        echo "preparing environment"
        utils.checkout(BUILD_VERSION,GIT_REPO,GIT_BRANCH,GIT_CHECKOUT)
    }

    stage('Run Custom Playbook') {
        ansible_main_vault = utils.findMainVault()
        ansible_additional_vaults = utils.prepareNonMainVaults()
        List credentials = [
            file(credentialsId: ansible_main_vault, variable: 'ANSIBLE_VAULT_PASSWORD_FILE'),
            string(credentialsId: 'sado_jenkins_zta_token', variable: 'ZTA_TOKEN'),
        ]
        withCredentials(credentials) {
            ansiColor('xterm') {
                def ansible_status
                String ansibleCmd = "ansible-playbook \${PLAYBOOK_NAME}  \${EXTRA_VARS}"

                 utils.callInDocker({
                    sshagent([deployer_id]) {
                        ansible_status = sh returnStatus: true, script: """
                            export ANSIBLE_FORCE_COLOR=true
                            \${ansibleCmd}
                        """
                    }
                })
                if(ansible_status != 0) {
                    def log_helper = new acronis.dco.LogHelper(this)
                    if (log_helper.getBuildLastNLines(120).join(' ').contains('ERROR! Specified hosts and/or --limit does not match any hosts')) {
                        currentBuild.result = 'SUCCESS'
                    } else {
                        currentBuild.result = 'FAILURE'
                    }
                }
            }
        }
    }
    stage('Trigger subjob for expiring certs'){
        script{
            if (fileExists(expiring_certs)) {
                echo "Expiring certs exists, continuing pipeline."
            }else{
                echo "No expiring certs. Ending pipeline with success."
                currentBuild.result = 'SUCCESS'
                return
            }
            try{
                def expiring_certs_file = readFile(expiring_certs).trim()
                def expiring_certs_list = readJSON text: expiring_certs_file
                def expiring_certs_list_pretty = JsonOutput.prettyPrint(JsonOutput.toJson(expiring_certs_list))
                if (!(expiring_certs_list instanceof List)){
                     error("The expiring_certs_list does not contain an array")
                }

                if (expiring_certs_list.size() < 1){
                    printToConsoleAndSendMessage("SSL Certificate Expiration Scan complete: No certificates approaching expiration [default threshold: 21 days].")
                }else{
                    echo "\${expiring_certs_list_pretty}"
                    printToConsoleAndSendMessage("\\nSSL Certificate Expiration Scan complete: \${expiring_certs_list.size()} certificate(s) approaching expiration")
                    expiring_certs_list.eachWithIndex{ item, index ->
                        def firstItem = (item?.ssl_check_output && item?.ssl_check_output.size() > 0) ? item?.ssl_check_output[0] : null
                        printToConsoleAndSendMessage("\\nExpiring Certificate \${index + 1} of \${expiring_certs_list.size()}:\\nPDC: \${item.pdc} \\nVDC:\${item?.vdc} \\nEnddate: \${firstItem} \\nJob: \${env.BUILD_URL}")
                    }

                    expiring_certs_list.each { item ->
                        try{
                            printToConsoleAndSendMessage( "Starting subjob to renew ssl certificate for \${item.project} in \${item.pdc} - \${item?.vdc}")
                            build(job: "ssl_certificate_update_subjob",
                                    parameters: [
                                            string(name: 'INVENTORY', value: INVENTORY),
                                            string(name: 'BUILD_VERSION', value: BUILD_VERSION),
                                            string(name: 'MASTER_WORKSPACE', value: "\${WORKSPACE}"),
                                            string(name: 'PLAYBOOK_NAME', value: PLAYBOOK_NAME),
                                            string(name: 'EXPIRINNG_CERTS_LIST', value: JsonOutput.toJson(item)),
                                            string(name: 'ANSIBLE_OPTIONS', value: " -e project=\${item.project} -e pdc=\${item.pdc} -e vdc=\${item.vdc} -e check_cert_expiry=\${false} -e renew_certificate=\${renew_certificate} -e dco_environment=production ")
                                    ]
                            )

                        }catch(error){
                            printToConsoleAndSendMessage("subjob failed for \${item.pdc}-\${item.vdc} in \${item.project}: \${error}")
                            error(error)
                        }
                    }
                }
            }catch (error){
                printToConsoleAndSendMessage("Error starting subjob to renew ssl certificate for \${item.project} in \${item.pdc} - \${item?.vdc}")
                echo "Error in stage: Trigger subjob for expiring certs"
                error("\${error}")
            }
        }
    }
}
